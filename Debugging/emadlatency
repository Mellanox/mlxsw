#!/usr/bin/python
#
# emadlatency   Summarize EMAD latency as a histogram.
#
# USAGE: emadlatecny [-h] [-T] [-r REG] [-q] [-w] [-v] [interval] [count]
#
# Based on biolatency from BCC.

from bcc import BPF
from time import sleep, strftime
import argparse

# Arguments
examples = """examples:
    ./emadlatecny           # summarize EMAD latency as a histogram
    ./emadlatency 1 10      # print 1 second summaries, 10 times
    ./emadlatency -T 1      # 1s summaries with timestamps
    ./emadlatency -r SFN    # measure latency of SFN EMAD only
    ./emadlatency -q        # only show latency of EMAD queries
    ./emadlatency -w        # only show latency of EMAD writes
    ./emadlatency -v        # verbose output, also show average latency
"""
parser = argparse.ArgumentParser(
    description="Summarize EMAD latency as a histogram",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=examples)
parser.add_argument("-T", "--timestamp", action="store_true",
                    help="include timestamp on output")
parser.add_argument("-r", "--register", type=str, default='',
                    help="only trace EMADs with provided register ID")
parser.add_argument("-q", "--queries", action="store_true",
                    help="only show EMAD queries")
parser.add_argument("-w", "--writes", action="store_true",
                    help="only show EMAD writes")
parser.add_argument("-v", "--verbose", action="store_true",
                    help="verbose output, also show average latency")
parser.add_argument("interval", nargs="?", default=99999999,
                    help="output interval, in seconds")
parser.add_argument("count", nargs="?", default=99999999,
                    help="number of outputs")
args = parser.parse_args()
countdown = int(args.count)
if not args.queries and not args.writes:
    args.queries = args.writes = True

# Define BPF program
bpf_text = """
#include <uapi/linux/ptrace.h>

#define MLXSW_EMAD_ETH_HDR_LEN          0x10
#define MLXSW_EMAD_OP_TLV_LEN           0x10
#define MLXSW_EMAD_OP_TLV_METHOD_MASK   0x7F
#define MLXSW_EMAD_REGISTERS_MAX        1024    /* Big enough */

enum {
	MLXSW_EMAD_OP_TLV_METHOD_QUERY = 1,
	MLXSW_EMAD_OP_TLV_METHOD_WRITE = 2,
	MLXSW_EMAD_OP_TLV_METHOD_EVENT = 5,
};

struct mlxsw_emad_op_tlv {
        u16 resv1;
        u8 status;
        u8 resv2;
        u16 register_id;
        u8 r_method;
        u8 resv3;
        u64 tid;
};

/* Histograms */
struct register_key {
        u16 register_id;
        u64 slot;
};

BPF_HASH(start, u64);
BPF_HISTOGRAM(dist_write, struct register_key, MLXSW_EMAD_REGISTERS_MAX);
BPF_HISTOGRAM(dist_query, struct register_key, MLXSW_EMAD_REGISTERS_MAX);

/* Averages */
struct avg_register_leaf {
    u64 total_latency;
    u64 count;
};

BPF_HASH(avg_write, u16, struct avg_register_leaf, MLXSW_EMAD_REGISTERS_MAX);
BPF_HASH(avg_query, u16, struct avg_register_leaf, MLXSW_EMAD_REGISTERS_MAX);

TRACEPOINT_PROBE(devlink, devlink_hwmsg) {
        u8 emad[MLXSW_EMAD_ETH_HDR_LEN + MLXSW_EMAD_OP_TLV_LEN];
        struct avg_register_leaf *leaf, zleaf = {};
        u64 *tsp, delta, ts = bpf_ktime_get_ns();
        struct mlxsw_emad_op_tlv *op_tlv;
        struct register_key key = {};

        TP_DATA_LOC_READ_CONST(emad, buf,
                               MLXSW_EMAD_ETH_HDR_LEN + MLXSW_EMAD_OP_TLV_LEN);
        op_tlv = (struct mlxsw_emad_op_tlv *)(emad + MLXSW_EMAD_ETH_HDR_LEN);

        FILTER

        if (!args->incoming) {
                start.update(&op_tlv->tid, &ts);
                return 0;
        }

        tsp = start.lookup(&op_tlv->tid);
        if (!tsp)
                return 0;

        delta = (bpf_ktime_get_ns() - *tsp) / 1000;
        key.slot = bpf_log2l(delta);
        key.register_id = ntohs(op_tlv->register_id);

        if ((op_tlv->r_method & MLXSW_EMAD_OP_TLV_METHOD_MASK) ==
             MLXSW_EMAD_OP_TLV_METHOD_QUERY) {
                dist_query.increment(key);
                leaf = avg_query.lookup_or_try_init(&key.register_id, &zleaf);
                if (leaf) {
                        lock_xadd(&leaf->total_latency, delta);
                        lock_xadd(&leaf->count, 1);
                }
        } else if ((op_tlv->r_method & MLXSW_EMAD_OP_TLV_METHOD_MASK) ==
                  MLXSW_EMAD_OP_TLV_METHOD_WRITE) {
                dist_write.increment(key);
                leaf = avg_write.lookup_or_try_init(&key.register_id, &zleaf);
                if (leaf) {
                        lock_xadd(&leaf->total_latency, delta);
                        lock_xadd(&leaf->count, 1);
                }
        }

        start.delete(&op_tlv->tid);

        return 0;
}
"""

# Code substitutions
REG_ID_DICT = {
    0x2000: "SGCR",
    0x2002: "SPAD",
    0x2007: "SMID",
    0x2008: "SSPR",
    0x2009: "SFDAT",
    0x200A: "SFD",
    0x200B: "SFN",
    0x200D: "SPMS",
    0x200E: "SPVID",
    0x200F: "SPVM",
    0x2010: "SPAFT",
    0x2011: "SFGC",
    0x2012: "SFTR",
    0x2013: "SFDF",
    0x2014: "SLDR",
    0x2015: "SLCR",
    0x2016: "SLCOR",
    0x2018: "SPMLR",
    0x201C: "SVFA",
    0x201E: "SVPE",
    0x201F: "SFMR",
    0x2020: "SPVMLR",
    0x2802: "CWTP",
    0x2803: "CWTPM",
    0x3001: "PGCR",
    0x3002: "PPBT",
    0x3004: "PACL",
    0x3005: "PAGT",
    0x3006: "PTAR",
    0x300C: "PPBS",
    0x300D: "PRCR",
    0x300F: "PEFA",
    0x3014: "PEMRBT",
    0x3017: "PTCE2",
    0x3021: "PERPT",
    0x3022: "PEABFE",
    0x3026: "PERAR",
    0x3027: "PTCE3",
    0x302A: "PERCR",
    0x302B: "PERERP",
    0x3804: "IEDR",
    0x4002: "QPTS",
    0x4004: "QPCR",
    0x400A: "QTCT",
    0x400D: "QEEC",
    0x400F: "QRWE",
    0x4011: "QPDSM",
    0x4007: "QPDP",
    0x4013: "QPDPM",
    0x401A: "QTCTM",
    0x401B: "QPSC",
    0x5002: "PMLP",
    0x5003: "PMTU",
    0x5004: "PTYS",
    0x5005: "PPAD",
    0x5006: "PAOS",
    0x5007: "PFCC",
    0x5008: "PPCNT",
    0x500A: "PLIB",
    0x500B: "PPTB",
    0x500C: "PBMC",
    0x500D: "PSPA",
    0x5018: "PPLR",
    0x5031: "PDDR",
    0x5067: "PMTM",
    0x7002: "HTGT",
    0x7003: "HPKT",
    0x8001: "RGCR",
    0x8002: "RITR",
    0x8004: "RTAR",
    0x8008: "RATR",
    0x8020: "RTDP",
    0x8009: "RDPM",
    0x800B: "RICNT",
    0x800F: "RRCR",
    0x8010: "RALTA",
    0x8011: "RALST",
    0x8012: "RALTB",
    0x8013: "RALUE",
    0x8014: "RAUHT",
    0x8015: "RALEU",
    0x8018: "RAUHTD",
    0x8023: "RIGR2",
    0x8025: "RECR2",
    0x8027: "RMFT2",
    0x9001: "MFCR",
    0x9002: "MFSC",
    0x9003: "MFSM",
    0x9004: "MFSL",
    0x9007: "FORE",
    0x9009: "MTCAP",
    0x900A: "MTMP",
    0x900F: "MTBR",
    0x9014: "MCIA",
    0x901A: "MPAT",
    0x901B: "MPAR",
    0x9020: "MGIR",
    0x9023: "MRSR",
    0x902B: "MLCR",
    0x9053: "MTPPS",
    0x9055: "MTUTC",
    0x9080: "MPSC",
    0x9061: "MCQI",
    0x9062: "MCC",
    0x9063: "MCDA",
    0x9081: "MGPC",
    0x9083: "MPRS",
    0x9086: "MOGCR",
    0x9089: "MPAGR",
    0x908D: "MOMTE",
    0x9090: "MTPPPC",
    0x9091: "MTPPTR",
    0x9092: "MTPTPT",
    0x90F0: "MFGD",
    0x9100: "MGPIR",
    0xA001: "TNGCR",
    0xA003: "TNUMT",
    0xA010: "TNQCR",
    0xA011: "TNQDR",
    0xA012: "TNEEM",
    0xA013: "TNDEM",
    0xA020: "TNPC",
    0xA801: "TIGCR",
    0xA812: "TIEEM",
    0xA813: "TIDEM",
    0xB001: "SBPR",
    0xB002: "SBCM",
    0xB003: "SBPM",
    0xB004: "SBMM",
    0xB005: "SBSR",
    0xB006: "SBIB"
}

if args.register:
    register_id = 0
    for k, v in REG_ID_DICT.items():
        if v == args.register:
            register_id = k
    if not register_id:
        print("ERROR: Invalid register ID. Exiting.")
        exit()

    bpf_text = bpf_text.replace('FILTER',
        'if (ntohs(op_tlv->register_id) != %u) return 0;' % register_id)
else:
    bpf_text=bpf_text.replace('FILTER', '')

# Load BPF program
b = BPF(text=bpf_text)

print("Tracing EMADs... Hit Ctrl-C to end.")

# Output
dist_query = b["dist_query"]
dist_write = b["dist_write"]
avg_query = b["avg_query"]
avg_write = b["avg_write"]

def print_register(avg_map, register_id):
    try:
        reg_name = REG_ID_DICT[register_id]
    except KeyError:
        reg_name = "Unknown register"

    val = "{0} ({1})".format(reg_name, hex(register_id))
    if args.verbose:
        for k, v in avg_map.items():
            if k.value == register_id:
                avg = v.total_latency // v.count
                val += "\n average = {0} usecs,".format(avg)
                val += " total = {0} usecs,".format(v.total_latency)
                val += " count = {0}".format(v.count)

    return val

def print_register_query(register_id):
    return print_register(avg_query, register_id)

def print_register_write(register_id):
    return print_register(avg_write, register_id)

exiting = 0 if args.interval else 1
while (1):
    try:
        sleep(int(args.interval))
    except KeyboardInterrupt:
        exiting = 1

    print()
    if args.timestamp:
        print("%-8s\n" % strftime("%H:%M:%S"), end="")

    if args.queries:
        dist_query.print_log2_hist("usecs", "Register query",
                                   print_register_query)
        dist_query.clear()
        avg_query.clear()
    if args.writes:
        dist_write.print_log2_hist("usecs", "Register write",
                                   print_register_write)
        dist_write.clear()
        avg_write.clear()

    countdown -= 1
    if exiting or countdown == 0:
        exit()
